<html>
<script src='https://d3js.org/d3.v6.min.js'></script>
<style>
  circle {
    fill: lightblue;
    stroke: black;
  }
</style>
<script async>

  function getRegionId(region) {
    return region.replaceAll(' ', '').replaceAll('&', '').replaceAll('-', '');
  }

  const dataFile = 'https://trotyltn.github.io/cs416_d3_dash/API_SP.POP.TOTL_DS2_en_csv_v2_1584446.csv';
  const metadataFile = 'https://trotyltn.github.io/cs416_d3_dash/Metadata_Country_API_SP.POP.TOTL_DS2_en_csv_v2_1584446.csv'

  const regions = [
    'East Asia & Pacific',
    'Europe & Central Asia',
    'Latin America & Caribbean',
    'Middle East & North Africa',
    'North America',
    'South Asia',
    'Sub-Saharan Africa',
  ];

  var popData = [];
  var countryMap = new Map();
  var countryPopData = [];

  var regionPopData = new Map();
  for (let r of regions) {
    regionPopData.set(r, new Object());
    for (let y = 1960; y <= 2023; y++) {
      regionPopData.get(r)[y] = 0;
    }
  }

  popPromise = d3.csv(dataFile).then((data) => {
    for (let i = 0; i < data.length; i++) {
      popData.push(data[i]);
    }
  });
  metadataPromise = d3.csv(metadataFile).then((data) => {
    for (let i = 0; i < data.length; i++) {
      countryMap.set(data[i]['Country Code'], data[i]['Region']);
    }
  });
  dataCompletePromise = Promise.all([popPromise, metadataPromise]).then(() => {
    countryPopData = popData.filter(d => countryMap.get(d['Country Code']));

    for (let d of countryPopData) {
      rd = regionPopData.get(countryMap.get(d['Country Code']));
      for (let y = 1960; y <= 2023; y++) {
        if (d[y]) {
          rd[y] += Number(d[y]);
        }
      }
    }
  });
</script>

<body>
  <div id="dataviz"></div>
  <script>
    dataCompletePromise.then(() => {
      console.log(countryMap);
      console.log(countryPopData);
      console.log(regionPopData);

      var margin = { top: 20, right: 10, bottom: 20, left: 90 };
      var width = 1000 - margin.left - margin.right;
      var height = 800 - margin.top - margin.bottom;

      var svg = d3.select("#dataviz")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .style("overflow", "visible")
        .on("pointerenter pointermove", pointermoved)
        .on("pointerleave", pointerleft)
        .on("touchstart", event => event.preventDefault())
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      var yearScale = d3.scaleLinear()
        .domain([1960, 2023])
        .range([0, width]);
      svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(yearScale).tickFormat(d3.format("0")));

      var maxRegionPop = Math.max(...regionPopData.values().map(d => Math.max(...Object.values(d))));
      var popScale = d3.scaleLinear()
        .domain([0, maxRegionPop])
        .range([height, 0]);

      svg.append("g")
        .call(d3.axisLeft(popScale).ticks(height / 40))
        .call(g => g.select(".domain").remove())
        .call(g => g.selectAll(".tick line").clone()
          .attr("x2", width)
          .attr("stroke-opacity", 0.1))
        .call(g => g.append("text")
          .attr("x", -margin.left)
          .attr("y", 10)
          .attr("fill", "currentColor")
          .attr("text-anchor", "start")
          .text("Total Population"));

      for (let region of regions) {
        svg.append("path")
          .datum(Object.entries(regionPopData.get(region)))
          .attr("fill", "none")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 1.5)
          .attr('id', getRegionId(region))
          .attr('class', getRegionId(region))
          .attr("d", d3.line()
            .x(function (d) { return yearScale(d[0]) })
            .y(function (d) { return popScale(d[1]) })
          );
      }

      const tooltip = svg.append("g");

      function pointermoved(event) {
        eventx = d3.pointer(event)[0] - margin.left;
        eventy = d3.pointer(event)[1] - margin.top;
        year = Math.round(yearScale.invert(eventx));
        if (year < 1960) year = 1960;
        if (year > 2023) year = 2023;
        pop = Math.round(popScale.invert(eventy));
        closestRegion = { 'name': 'N/A', 'pop': 0, 'diff': Number.MAX_SAFE_INTEGER };
        for (let region of regions) {
          diff = Math.abs(pop - regionPopData.get(region)[year]);
          if (diff < closestRegion['diff']) {
            closestRegion = { 'name': region, 'pop': regionPopData.get(region)[year], 'diff': diff };
          }
        }

        tooltip.style("display", null);
        tooltip.attr("transform", `translate(${yearScale(year)},${popScale(closestRegion['pop'])})`);

        const path = tooltip.selectAll("path")
          .data([,])
          .join("path")
          .attr("fill", "white")
          .attr("stroke", "black");

        const text = tooltip.selectAll("text")
          .data([,])
          .join("text")
          .call(text => text
            .selectAll("tspan")
            .data([
              `${closestRegion['name']} ${year}`,
              `Total Pop: ${closestRegion['pop'].toLocaleString()}`])
            .join("tspan")
            .attr("x", 0)
            .attr("y", (_, i) => `${i * 1.1}em`)
            .attr("font-weight", (_, i) => i ? null : "bold")
            .text(d => d));
        const { x, y, width: w, height: h } = text.node().getBBox();
        text.attr("transform", `translate(${-w / 2},${15 - y})`);
        path.attr("d", `M${-w / 2 - 10},5H-5l5,-5l5,5H${w / 2 + 10}v${h + 20}h-${w + 20}z`);
      }

      function pointerleft() {
        tooltip.style("display", "none");
      }
    });
  </script>
</body>

</html>